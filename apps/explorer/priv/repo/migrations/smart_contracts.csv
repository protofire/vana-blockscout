id,name,compiler_version,optimization,contract_source_code,abi,address_hash,inserted_at,updated_at,constructor_arguments,optimization_runs,evm_version,external_libraries,verified_via_sourcify,is_vyper_contract,partially_verified,file_path,is_changed_bytecode,bytecode_checked_at,contract_code_md5,compiler_settings,verified_via_eth_bytecode_db,license_type,verified_via_verifier_alliance,certified,is_blueprint,language
652,DLPRootMetricsProxy,v0.8.24+commit.e11b9ed9,TRUE,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";

contract DLPRootMetricsProxy is ERC1967Proxy {
    constructor(address logic, bytes memory data) ERC1967Proxy(logic, data) {}
}
","[{""type"": ""constructor"", ""inputs"": [{""name"": ""logic"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""data"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""stateMutability"": ""nonpayable""}, {""name"": ""AddressEmptyCode"", ""type"": ""error"", ""inputs"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967InvalidImplementation"", ""type"": ""error"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967NonPayable"", ""type"": ""error"", ""inputs"": []}, {""name"": ""FailedInnerCall"", ""type"": ""error"", ""inputs"": []}, {""name"": ""Upgraded"", ""type"": ""event"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""indexed"": true, ""internalType"": ""address""}], ""anonymous"": false}, {""type"": ""fallback"", ""stateMutability"": ""payable""}]",0xBB532917B6407C060AFD9CB7D53527ECB91D6662,2025-01-03 12:53:19,2025-02-19 17:07:37,00000000000000000000000023392c2c60507f5e69064ae6ebd5d91654cf467b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a4a6b63eb800000000000000000000000000000000000000000000000000000000000000000000000000000000000000002ac93684679a5bda03c6160def908cdb8d46792f000000000000000000000000ff14346df2b8fd0c95bf34f1c92e49417b508ad5000000000000000000000000000000000000000000000004563918244f400000000000000000000000000000000000000000000000000001158e460913d0000000000000000000000000000000000000000000000000000000000000,1,paris,{},FALSE,FALSE,FALSE,contracts/rootMetrics/DLPRootMetricsProxy.sol,FALSE,2025-02-19 17:07:37,cada6c226ce94952aa72947ce9e8336c,"{""metadata"": {""useLiteralContent"": true}, ""libraries"": {}, ""optimizer"": {""runs"": 1, ""enabled"": true}, ""evmVersion"": ""paris"", ""outputSelection"": {""*"": {"""": [""ast""], ""*"": [""abi"", ""evm.bytecode"", ""evm.deployedBytecode"", ""evm.methodIdentifiers"", ""metadata"", ""storageLayout"", ""devdoc"", ""userdoc"", ""evm.gasEstimates""]}}}",TRUE,1,FALSE,,FALSE,1
655,DLPRootStakesTreasuryProxy,v0.8.24+commit.e11b9ed9,TRUE,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";

contract DLPRootStakesTreasuryProxy is ERC1967Proxy {
    constructor(address logic, bytes memory data) ERC1967Proxy(logic, data) {}
}
","[{""type"": ""constructor"", ""inputs"": [{""name"": ""logic"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""data"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""stateMutability"": ""nonpayable""}, {""name"": ""AddressEmptyCode"", ""type"": ""error"", ""inputs"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967InvalidImplementation"", ""type"": ""error"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967NonPayable"", ""type"": ""error"", ""inputs"": []}, {""name"": ""FailedInnerCall"", ""type"": ""error"", ""inputs"": []}, {""name"": ""Upgraded"", ""type"": ""event"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""indexed"": true, ""internalType"": ""address""}], ""anonymous"": false}, {""type"": ""fallback"", ""stateMutability"": ""payable""}]",0x52C3260ED5C235FCA43524CF508E29C897318775,2025-01-03 12:58:57,2025-02-19 17:07:49,0x00000000000000000000000063b1dbc516e9d795f64ab9800946f46219cbfa7e00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000044485cc9550000000000000000000000002ac93684679a5bda03c6160def908cdb8d46792f000000000000000000000000ff14346df2b8fd0c95bf34f1c92e49417b508ad500000000000000000000000000000000000000000000000000000000,1,paris,{},FALSE,FALSE,FALSE,contracts/rootTreasury/DLPRootStakesTreasuryProxy.sol,FALSE,2025-02-19 17:07:49,5ee6bc74ff51ccd1c0cd89e2115076f6,"{""metadata"": {""useLiteralContent"": true}, ""libraries"": {}, ""optimizer"": {""runs"": 1, ""enabled"": true}, ""evmVersion"": ""paris"", ""outputSelection"": {""*"": {"""": [""ast""], ""*"": [""abi"", ""evm.bytecode"", ""evm.deployedBytecode"", ""evm.methodIdentifiers"", ""metadata"", ""storageLayout"", ""devdoc"", ""userdoc"", ""evm.gasEstimates""]}}}",FALSE,1,FALSE,,FALSE,1
133,MultisendProxy,v0.8.24+commit.e11b9ed9,TRUE,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";

contract MultisendProxy is ERC1967Proxy {
    constructor(address logic, bytes memory data) ERC1967Proxy(logic, data) {}
}
","[{""type"": ""constructor"", ""inputs"": [{""name"": ""logic"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""data"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""stateMutability"": ""nonpayable""}, {""name"": ""AddressEmptyCode"", ""type"": ""error"", ""inputs"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967InvalidImplementation"", ""type"": ""error"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967NonPayable"", ""type"": ""error"", ""inputs"": []}, {""name"": ""FailedInnerCall"", ""type"": ""error"", ""inputs"": []}, {""name"": ""Upgraded"", ""type"": ""event"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""indexed"": true, ""internalType"": ""address""}], ""anonymous"": false}, {""type"": ""fallback"", ""stateMutability"": ""payable""}]",0x8807E8BCDFBAA8C2761760F3FBA37F6F7F2C5B2D,2024-12-15 16:39:36,2025-02-20 13:08:14,000000000000000000000000a456b1197f413ffd09c9fa1079a89b5db3a4a81400000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000024c4d66de80000000000000000000000002ac93684679a5bda03c6160def908cdb8d46792f00000000000000000000000000000000000000000000000000000000,1,paris,{},FALSE,FALSE,FALSE,contracts/multisend/MultisendProxy.sol,FALSE,2025-02-20 13:08:14,3060a1d1bd8171518054c3992d2a55c4,"{""metadata"": {""useLiteralContent"": true}, ""libraries"": {}, ""optimizer"": {""runs"": 1, ""enabled"": true}, ""evmVersion"": ""paris"", ""outputSelection"": {""*"": {"""": [""ast""], ""*"": [""abi"", ""evm.bytecode"", ""evm.deployedBytecode"", ""evm.methodIdentifiers"", ""metadata"", ""storageLayout"", ""devdoc"", ""userdoc"", ""evm.gasEstimates""]}}}",TRUE,1,FALSE,,FALSE,
11,Multicall3,v0.8.24+commit.e11b9ed9,TRUE,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

/// @title Multicall3
/// @notice Aggregate results from multiple function calls
/// @dev Multicall & Multicall2 backwards-compatible
/// @dev Aggregate methods are marked `payable` to save 24 gas per call
/// @author Michael Elliot <mike@makerdao.com>
/// @author Joshua Levine <joshua@makerdao.com>
/// @author Nick Johnson <arachnid@notdot.net>
/// @author Andreas Bigger <andreas@nascent.xyz>
/// @author Matt Solomon <matt@mattsolomon.dev>
contract Multicall3 {
    struct Call {
        address target;
        bytes callData;
    }

    struct Call3 {
        address target;
        bool allowFailure;
        bytes callData;
    }

    struct Call3Value {
        address target;
        bool allowFailure;
        uint256 value;
        bytes callData;
    }

    struct Result {
        bool success;
        bytes returnData;
    }

    /// @notice Backwards-compatible call aggregation with Multicall
    /// @param calls An array of Call structs
    /// @return blockNumber The block number where the calls were executed
    /// @return returnData An array of bytes containing the responses
    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {
        blockNumber = block.number;
        uint256 length = calls.length;
        returnData = new bytes[](length);
        Call calldata call;
        for (uint256 i = 0; i < length; ) {
            bool success;
            call = calls[i];
            (success, returnData[i]) = call.target.call(call.callData);
            require(success, ""Multicall3: call failed"");
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Backwards-compatible with Multicall2
    /// @notice Aggregate calls without requiring success
    /// @param requireSuccess If true, require all calls to succeed
    /// @param calls An array of Call structs
    /// @return returnData An array of Result structs
    function tryAggregate(
        bool requireSuccess,
        Call[] calldata calls
    ) public payable returns (Result[] memory returnData) {
        uint256 length = calls.length;
        returnData = new Result[](length);
        Call calldata call;
        for (uint256 i = 0; i < length; ) {
            Result memory result = returnData[i];
            call = calls[i];
            (result.success, result.returnData) = call.target.call(call.callData);
            if (requireSuccess) require(result.success, ""Multicall3: call failed"");
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Backwards-compatible with Multicall2
    /// @notice Aggregate calls and allow failures using tryAggregate
    /// @param calls An array of Call structs
    /// @return blockNumber The block number where the calls were executed
    /// @return blockHash The hash of the block where the calls were executed
    /// @return returnData An array of Result structs
    function tryBlockAndAggregate(
        bool requireSuccess,
        Call[] calldata calls
    ) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {
        blockNumber = block.number;
        blockHash = blockhash(block.number);
        returnData = tryAggregate(requireSuccess, calls);
    }

    /// @notice Backwards-compatible with Multicall2
    /// @notice Aggregate calls and allow failures using tryAggregate
    /// @param calls An array of Call structs
    /// @return blockNumber The block number where the calls were executed
    /// @return blockHash The hash of the block where the calls were executed
    /// @return returnData An array of Result structs
    function blockAndAggregate(
        Call[] calldata calls
    ) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {
        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);
    }

    /// @notice Aggregate calls, ensuring each returns success if required
    /// @param calls An array of Call3 structs
    /// @return returnData An array of Result structs
    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {
        uint256 length = calls.length;
        returnData = new Result[](length);
        Call3 calldata calli;
        for (uint256 i = 0; i < length; ) {
            Result memory result = returnData[i];
            calli = calls[i];
            (result.success, result.returnData) = calli.target.call(calli.callData);
            assembly {
                // Revert if the call fails and failure is not allowed
                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`
                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {
                    // set ""Error(string)"" signature: bytes32(bytes4(keccak256(""Error(string)"")))
                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                    // set data offset
                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)
                    // set length of revert string
                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)
                    // set revert string: bytes32(abi.encodePacked(""Multicall3: call failed""))
                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)
                    revert(0x00, 0x64)
                }
            }
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Aggregate calls with a msg value
    /// @notice Reverts if msg.value is less than the sum of the call values
    /// @param calls An array of Call3Value structs
    /// @return returnData An array of Result structs
    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {
        uint256 valAccumulator;
        uint256 length = calls.length;
        returnData = new Result[](length);
        Call3Value calldata calli;
        for (uint256 i = 0; i < length; ) {
            Result memory result = returnData[i];
            calli = calls[i];
            uint256 val = calli.value;
            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas
            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256
            unchecked {
                valAccumulator += val;
            }
            (result.success, result.returnData) = calli.target.call{value: val}(calli.callData);
            assembly {
                // Revert if the call fails and failure is not allowed
                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`
                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {
                    // set ""Error(string)"" signature: bytes32(bytes4(keccak256(""Error(string)"")))
                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                    // set data offset
                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)
                    // set length of revert string
                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)
                    // set revert string: bytes32(abi.encodePacked(""Multicall3: call failed""))
                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)
                    revert(0x00, 0x84)
                }
            }
            unchecked {
                ++i;
            }
        }
        // Finally, make sure the msg.value = SUM(call[0...i].value)
        require(msg.value == valAccumulator, ""Multicall3: value mismatch"");
    }

    /// @notice Returns the block hash for the given block number
    /// @param blockNumber The block number
    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {
        blockHash = blockhash(blockNumber);
    }

    /// @notice Returns the block number
    function getBlockNumber() public view returns (uint256 blockNumber) {
        blockNumber = block.number;
    }

    /// @notice Returns the block coinbase
    function getCurrentBlockCoinbase() public view returns (address coinbase) {
        coinbase = block.coinbase;
    }

    /// @notice Returns the block difficulty
    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {
        difficulty = block.difficulty;
    }

    /// @notice Returns the block gas limit
    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {
        gaslimit = block.gaslimit;
    }

    /// @notice Returns the block timestamp
    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {
        timestamp = block.timestamp;
    }

    /// @notice Returns the (ETH) balance of a given address
    function getEthBalance(address addr) public view returns (uint256 balance) {
        balance = addr.balance;
    }

    /// @notice Returns the block hash of the last block
    function getLastBlockHash() public view returns (bytes32 blockHash) {
        unchecked {
            blockHash = blockhash(block.number - 1);
        }
    }

    /// @notice Gets the base fee of the given block
    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain
    function getBasefee() public view returns (uint256 basefee) {
        basefee = block.basefee;
    }

    /// @notice Returns the chain id
    function getChainId() public view returns (uint256 chainid) {
        chainid = block.chainid;
    }
}
","[{""name"": ""aggregate"", ""type"": ""function"", ""inputs"": [{""name"": ""calls"", ""type"": ""tuple[]"", ""components"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""callData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Call[]""}], ""outputs"": [{""name"": ""blockNumber"", ""type"": ""uint256"", ""internalType"": ""uint256""}, {""name"": ""returnData"", ""type"": ""bytes[]"", ""internalType"": ""bytes[]""}], ""stateMutability"": ""payable""}, {""name"": ""aggregate3"", ""type"": ""function"", ""inputs"": [{""name"": ""calls"", ""type"": ""tuple[]"", ""components"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""allowFailure"", ""type"": ""bool"", ""internalType"": ""bool""}, {""name"": ""callData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Call3[]""}], ""outputs"": [{""name"": ""returnData"", ""type"": ""tuple[]"", ""components"": [{""name"": ""success"", ""type"": ""bool"", ""internalType"": ""bool""}, {""name"": ""returnData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Result[]""}], ""stateMutability"": ""payable""}, {""name"": ""aggregate3Value"", ""type"": ""function"", ""inputs"": [{""name"": ""calls"", ""type"": ""tuple[]"", ""components"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""allowFailure"", ""type"": ""bool"", ""internalType"": ""bool""}, {""name"": ""value"", ""type"": ""uint256"", ""internalType"": ""uint256""}, {""name"": ""callData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Call3Value[]""}], ""outputs"": [{""name"": ""returnData"", ""type"": ""tuple[]"", ""components"": [{""name"": ""success"", ""type"": ""bool"", ""internalType"": ""bool""}, {""name"": ""returnData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Result[]""}], ""stateMutability"": ""payable""}, {""name"": ""blockAndAggregate"", ""type"": ""function"", ""inputs"": [{""name"": ""calls"", ""type"": ""tuple[]"", ""components"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""callData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Call[]""}], ""outputs"": [{""name"": ""blockNumber"", ""type"": ""uint256"", ""internalType"": ""uint256""}, {""name"": ""blockHash"", ""type"": ""bytes32"", ""internalType"": ""bytes32""}, {""name"": ""returnData"", ""type"": ""tuple[]"", ""components"": [{""name"": ""success"", ""type"": ""bool"", ""internalType"": ""bool""}, {""name"": ""returnData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Result[]""}], ""stateMutability"": ""payable""}, {""name"": ""getBasefee"", ""type"": ""function"", ""inputs"": [], ""outputs"": [{""name"": ""basefee"", ""type"": ""uint256"", ""internalType"": ""uint256""}], ""stateMutability"": ""view""}, {""name"": ""getBlockHash"", ""type"": ""function"", ""inputs"": [{""name"": ""blockNumber"", ""type"": ""uint256"", ""internalType"": ""uint256""}], ""outputs"": [{""name"": ""blockHash"", ""type"": ""bytes32"", ""internalType"": ""bytes32""}], ""stateMutability"": ""view""}, {""name"": ""getBlockNumber"", ""type"": ""function"", ""inputs"": [], ""outputs"": [{""name"": ""blockNumber"", ""type"": ""uint256"", ""internalType"": ""uint256""}], ""stateMutability"": ""view""}, {""name"": ""getChainId"", ""type"": ""function"", ""inputs"": [], ""outputs"": [{""name"": ""chainid"", ""type"": ""uint256"", ""internalType"": ""uint256""}], ""stateMutability"": ""view""}, {""name"": ""getCurrentBlockCoinbase"", ""type"": ""function"", ""inputs"": [], ""outputs"": [{""name"": ""coinbase"", ""type"": ""address"", ""internalType"": ""address""}], ""stateMutability"": ""view""}, {""name"": ""getCurrentBlockDifficulty"", ""type"": ""function"", ""inputs"": [], ""outputs"": [{""name"": ""difficulty"", ""type"": ""uint256"", ""internalType"": ""uint256""}], ""stateMutability"": ""view""}, {""name"": ""getCurrentBlockGasLimit"", ""type"": ""function"", ""inputs"": [], ""outputs"": [{""name"": ""gaslimit"", ""type"": ""uint256"", ""internalType"": ""uint256""}], ""stateMutability"": ""view""}, {""name"": ""getCurrentBlockTimestamp"", ""type"": ""function"", ""inputs"": [], ""outputs"": [{""name"": ""timestamp"", ""type"": ""uint256"", ""internalType"": ""uint256""}], ""stateMutability"": ""view""}, {""name"": ""getEthBalance"", ""type"": ""function"", ""inputs"": [{""name"": ""addr"", ""type"": ""address"", ""internalType"": ""address""}], ""outputs"": [{""name"": ""balance"", ""type"": ""uint256"", ""internalType"": ""uint256""}], ""stateMutability"": ""view""}, {""name"": ""getLastBlockHash"", ""type"": ""function"", ""inputs"": [], ""outputs"": [{""name"": ""blockHash"", ""type"": ""bytes32"", ""internalType"": ""bytes32""}], ""stateMutability"": ""view""}, {""name"": ""tryAggregate"", ""type"": ""function"", ""inputs"": [{""name"": ""requireSuccess"", ""type"": ""bool"", ""internalType"": ""bool""}, {""name"": ""calls"", ""type"": ""tuple[]"", ""components"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""callData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Call[]""}], ""outputs"": [{""name"": ""returnData"", ""type"": ""tuple[]"", ""components"": [{""name"": ""success"", ""type"": ""bool"", ""internalType"": ""bool""}, {""name"": ""returnData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Result[]""}], ""stateMutability"": ""payable""}, {""name"": ""tryBlockAndAggregate"", ""type"": ""function"", ""inputs"": [{""name"": ""requireSuccess"", ""type"": ""bool"", ""internalType"": ""bool""}, {""name"": ""calls"", ""type"": ""tuple[]"", ""components"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""callData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Call[]""}], ""outputs"": [{""name"": ""blockNumber"", ""type"": ""uint256"", ""internalType"": ""uint256""}, {""name"": ""blockHash"", ""type"": ""bytes32"", ""internalType"": ""bytes32""}, {""name"": ""returnData"", ""type"": ""tuple[]"", ""components"": [{""name"": ""success"", ""type"": ""bool"", ""internalType"": ""bool""}, {""name"": ""returnData"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""internalType"": ""struct Multicall3.Result[]""}], ""stateMutability"": ""payable""}]",0xD8D2DFCA27E8797FD779F8547166A2D3B29D360E,2024-11-27 15:51:36,2025-01-22 9:12:22,,200,paris,{},FALSE,FALSE,FALSE,contracts/multicall3/Multicall3.sol,FALSE,2025-01-22 9:12:22,c3cf85fd8b90ddf41b8ad6109df9c9b8,"{""metadata"": {""useLiteralContent"": true}, ""libraries"": {}, ""optimizer"": {""runs"": 200, ""enabled"": true}, ""evmVersion"": ""paris"", ""outputSelection"": {""*"": {"""": [""ast""], ""*"": [""abi"", ""evm.bytecode"", ""evm.deployedBytecode"", ""evm.methodIdentifiers"", ""metadata"", ""storageLayout"", ""devdoc"", ""userdoc"", ""evm.gasEstimates""]}}}",FALSE,1,FALSE,,FALSE,
18,DataRegistryProxy,v0.8.24+commit.e11b9ed9,TRUE,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";

contract DataRegistryProxy is ERC1967Proxy {
    constructor(address logic, bytes memory data) ERC1967Proxy(logic, data) {}
}
","[{""type"": ""constructor"", ""inputs"": [{""name"": ""logic"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""data"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""stateMutability"": ""nonpayable""}, {""name"": ""AddressEmptyCode"", ""type"": ""error"", ""inputs"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967InvalidImplementation"", ""type"": ""error"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967NonPayable"", ""type"": ""error"", ""inputs"": []}, {""name"": ""FailedInnerCall"", ""type"": ""error"", ""inputs"": []}, {""name"": ""Upgraded"", ""type"": ""event"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""indexed"": true, ""internalType"": ""address""}], ""anonymous"": false}, {""type"": ""fallback"", ""stateMutability"": ""payable""}]",0x8C8788F98385F6BA1ADD4234E551ABBA0F82CB7C,2024-11-30 13:33:53,2025-02-20 5:35:33,00000000000000000000000026b42ae6806d432c89641a4665fb68e3366bc38a00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000044485cc95500000000000000000000000000000000000000000000000000000000000000000000000000000000000000002ac93684679a5bda03c6160def908cdb8d46792f00000000000000000000000000000000000000000000000000000000,200,paris,{},FALSE,FALSE,FALSE,contracts/dataRegistry/DataRegistryProxy.sol,FALSE,2025-02-20 5:35:33,77cedfaed0cebd53a23613202c3afc19,"{""metadata"": {""useLiteralContent"": true}, ""libraries"": {}, ""optimizer"": {""runs"": 200, ""enabled"": true}, ""evmVersion"": ""paris"", ""outputSelection"": {""*"": {"""": [""ast""], ""*"": [""abi"", ""evm.bytecode"", ""evm.deployedBytecode"", ""evm.methodIdentifiers"", ""metadata"", ""storageLayout"", ""devdoc"", ""userdoc"", ""evm.gasEstimates""]}}}",TRUE,1,FALSE,,FALSE,
53,TeePoolPhalaProxy,v0.8.24+commit.e11b9ed9,TRUE,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";

contract TeePoolPhalaProxy is ERC1967Proxy {
    constructor(address logic, bytes memory data) ERC1967Proxy(logic, data) {
        require(true, ""Phala"");
    }
}
","[{""type"": ""constructor"", ""inputs"": [{""name"": ""logic"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""data"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""stateMutability"": ""nonpayable""}, {""name"": ""AddressEmptyCode"", ""type"": ""error"", ""inputs"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967InvalidImplementation"", ""type"": ""error"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967NonPayable"", ""type"": ""error"", ""inputs"": []}, {""name"": ""FailedInnerCall"", ""type"": ""error"", ""inputs"": []}, {""name"": ""Upgraded"", ""type"": ""event"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""indexed"": true, ""internalType"": ""address""}], ""anonymous"": false}, {""type"": ""fallback"", ""stateMutability"": ""payable""}]",0xE8EC6BD73B23AD40E6B9A6F4BD343FAC411BD99A,2024-12-04 17:34:21,2025-02-19 22:01:54,00000000000000000000000025bba03174b340522f679cc18019c0db241a8a7000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000084cf756fdf00000000000000000000000000000000000000000000000000000000000000000000000000000000000000002ac93684679a5bda03c6160def908cdb8d46792f0000000000000000000000008c8788f98385f6ba1add4234e551abba0f82cb7c000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000,1,paris,{},FALSE,FALSE,FALSE,contracts/teePool/TeePoolProxy.sol,FALSE,2025-02-19 22:01:53,943621f8e6c4ff129de88c33a994276f,"{""metadata"": {""useLiteralContent"": true}, ""libraries"": {}, ""optimizer"": {""runs"": 1, ""enabled"": true}, ""evmVersion"": ""paris"", ""outputSelection"": {""*"": {"""": [""ast""], ""*"": [""abi"", ""evm.bytecode"", ""evm.deployedBytecode"", ""evm.methodIdentifiers"", ""metadata"", ""storageLayout"", ""devdoc"", ""userdoc"", ""evm.gasEstimates""]}}}",TRUE,1,FALSE,,FALSE,
20,TeePoolProxy,v0.8.24+commit.e11b9ed9,TRUE,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";

contract TeePoolProxy is ERC1967Proxy {
    constructor(address logic, bytes memory data) ERC1967Proxy(logic, data) {}
}
","[{""type"": ""constructor"", ""inputs"": [{""name"": ""logic"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""data"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""stateMutability"": ""nonpayable""}, {""name"": ""AddressEmptyCode"", ""type"": ""error"", ""inputs"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967InvalidImplementation"", ""type"": ""error"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967NonPayable"", ""type"": ""error"", ""inputs"": []}, {""name"": ""FailedInnerCall"", ""type"": ""error"", ""inputs"": []}, {""name"": ""Upgraded"", ""type"": ""event"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""indexed"": true, ""internalType"": ""address""}], ""anonymous"": false}, {""type"": ""fallback"", ""stateMutability"": ""payable""}]",0x3C92FD91639B41F13338CE62F19131E7D19EAA0D,2024-11-30 13:39:03,2025-02-20 14:02:14,0x00000000000000000000000051a6aab60026e5dce3f0bc24cc751a958eddbc0800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000084cf756fdf00000000000000000000000000000000000000000000000000000000000000000000000000000000000000002ac93684679a5bda03c6160def908cdb8d46792f0000000000000000000000008c8788f98385f6ba1add4234e551abba0f82cb7c000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000,200,paris,{},FALSE,FALSE,FALSE,contracts/teePool/TeePoolProxy.sol,FALSE,2025-02-20 14:02:14,f4ab8e93cd8656e5e62342dec1393b22,"{""metadata"": {""useLiteralContent"": true}, ""libraries"": {}, ""optimizer"": {""runs"": 200, ""enabled"": true}, ""evmVersion"": ""paris"", ""outputSelection"": {""*"": {"""": [""ast""], ""*"": [""abi"", ""evm.bytecode"", ""evm.deployedBytecode"", ""evm.methodIdentifiers"", ""metadata"", ""storageLayout"", ""devdoc"", ""userdoc"", ""evm.gasEstimates""]}}}",FALSE,1,FALSE,,FALSE,
37,DLPRootProxy,v0.8.24+commit.e11b9ed9,TRUE,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";

contract DLPRootProxy is ERC1967Proxy {
    constructor(address logic, bytes memory data) ERC1967Proxy(logic, data) {}
}
","[{""type"": ""constructor"", ""inputs"": [{""name"": ""logic"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""data"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""stateMutability"": ""nonpayable""}, {""name"": ""AddressEmptyCode"", ""type"": ""error"", ""inputs"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967InvalidImplementation"", ""type"": ""error"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967NonPayable"", ""type"": ""error"", ""inputs"": []}, {""name"": ""FailedInnerCall"", ""type"": ""error"", ""inputs"": []}, {""name"": ""Upgraded"", ""type"": ""event"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""indexed"": true, ""internalType"": ""address""}], ""anonymous"": false}, {""type"": ""fallback"", ""stateMutability"": ""payable""}]",0xFF14346DF2B8FD0C95BF34F1C92E49417B508AD5,2024-12-02 21:29:45,2025-02-20 1:33:22,00000000000000000000000009796c94fb6016e592876191276e51726990f02b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000204387548b500000000000000000000000000000000000000000000000000000000000000000000000000000000000000002ac93684679a5bda03c6160def908cdb8d46792f00000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000002b5e3af16b1880000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000056bc75e2d6310000000000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000021e19e0c9bab24000000000000000000000000000000000000000000000000000000000000000001068000000000000000000000000000000000000000000000000000000000000313800000000000000000000000000000000000000000000000000000000000d84f000000000000000000000000000000000000000000000000000000000000031380000000000000000000000000000000000000000000000000000000000000258000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,1,paris,{},FALSE,FALSE,FALSE,contracts/root/DLPRootProxy.sol,FALSE,2025-02-20 1:33:22,412e9c482ee9f9a5fbcb90b38806007b,"{""metadata"": {""useLiteralContent"": true}, ""libraries"": {}, ""optimizer"": {""runs"": 1, ""enabled"": true}, ""evmVersion"": ""paris"", ""outputSelection"": {""*"": {"""": [""ast""], ""*"": [""abi"", ""evm.bytecode"", ""evm.deployedBytecode"", ""evm.methodIdentifiers"", ""metadata"", ""storageLayout"", ""devdoc"", ""userdoc"", ""evm.gasEstimates""]}}}",TRUE,1,FALSE,,FALSE,1
654,DLPRootRewardsTreasuryProxy,v0.8.24+commit.e11b9ed9,TRUE,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";

contract DLPRootRewardsTreasuryProxy is ERC1967Proxy {
    constructor(address logic, bytes memory data) ERC1967Proxy(logic, data) {}
}
","[{""type"": ""constructor"", ""inputs"": [{""name"": ""logic"", ""type"": ""address"", ""internalType"": ""address""}, {""name"": ""data"", ""type"": ""bytes"", ""internalType"": ""bytes""}], ""stateMutability"": ""nonpayable""}, {""name"": ""AddressEmptyCode"", ""type"": ""error"", ""inputs"": [{""name"": ""target"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967InvalidImplementation"", ""type"": ""error"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""internalType"": ""address""}]}, {""name"": ""ERC1967NonPayable"", ""type"": ""error"", ""inputs"": []}, {""name"": ""FailedInnerCall"", ""type"": ""error"", ""inputs"": []}, {""name"": ""Upgraded"", ""type"": ""event"", ""inputs"": [{""name"": ""implementation"", ""type"": ""address"", ""indexed"": true, ""internalType"": ""address""}], ""anonymous"": false}, {""type"": ""fallback"", ""stateMutability"": ""payable""}]",0xDBFB6B8B9E2ECAEBDE64D665CD553DB81E524479,2025-01-03 12:57:06,2025-02-20 14:01:58,00000000000000000000000063b1dbc516e9d795f64ab9800946f46219cbfa7e00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000044485cc9550000000000000000000000002ac93684679a5bda03c6160def908cdb8d46792f000000000000000000000000ff14346df2b8fd0c95bf34f1c92e49417b508ad500000000000000000000000000000000000000000000000000000000,1,paris,{},FALSE,FALSE,FALSE,contracts/rootTreasury/DLPRootRewardsTreasuryProxy.sol,FALSE,2025-02-20 14:01:58,f50a64761a5e98719488d8bab95879c4,"{""metadata"": {""useLiteralContent"": true}, ""libraries"": {}, ""optimizer"": {""runs"": 1, ""enabled"": true}, ""evmVersion"": ""paris"", ""outputSelection"": {""*"": {"""": [""ast""], ""*"": [""abi"", ""evm.bytecode"", ""evm.deployedBytecode"", ""evm.methodIdentifiers"", ""metadata"", ""storageLayout"", ""devdoc"", ""userdoc"", ""evm.gasEstimates""]}}}",TRUE,1,FALSE,,FALSE,1